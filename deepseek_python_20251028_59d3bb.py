import os
import re
import requests
import time
import asyncio
import math
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
from concurrent.futures import ThreadPoolExecutor
import logging

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class AdvancedRASDownloader:
    def __init__(self):
        self.download_dir = "ras_downloads"
        self.max_workers = 3
        os.makedirs(self.download_dir, exist_ok=True)
    
    def extract_links_from_text(self, text):
        """‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§∏‡•á ‡§∏‡§æ‡§∞‡•á ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§≤‡§ø‡§Ç‡§ï‡•ç‡§∏ ‡§®‡§ø‡§ï‡§æ‡§≤‡•á‡§Ç"""
        links = []
        
        pattern = r'\(([^)]+)\)\s*(.*?)\s*(https://[^\s]+)'
        matches = re.findall(pattern, text)
        
        for i, match in enumerate(matches):
            subject = match[0].strip()
            description = match[1].strip()
            url = match[2].strip()
            
            if '.pdf' in url.lower():
                file_type = 'pdf'
            elif '.mp4' in url.lower() or 'video' in url.lower():
                file_type = 'mp4'
            else:
                file_type = 'file'
            
            safe_subject = re.sub(r'[^\w\s-]', '', subject)
            safe_description = re.sub(r'[^\w\s-]', '', description)
            safe_description = re.sub(r'\s+', '_', safe_description)
            
            filename = f"{i+1:03d}_{safe_subject}_{safe_description}.{file_type}"
            
            links.append({
                'id': i + 1,
                'subject': subject,
                'description': description,
                'url': url,
                'filename': filename,
                'type': file_type,
                'status': 'pending',
                'progress': 0,
                'size': 0,
                'downloaded': 0
            })
        
        return links
    
    def download_file_with_progress(self, link, progress_callback=None):
        """‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡•á‡§∏ ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó ‡§ï‡•á ‡§∏‡§æ‡§• ‡§´‡§æ‡§á‡§≤ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç"""
        try:
            filepath = os.path.join(self.download_dir, link['filename'])
            link['status'] = 'downloading'
            
            if os.path.exists(filepath):
                link['status'] = 'completed'
                link['progress'] = 100
                if progress_callback:
                    progress_callback(link)
                return {'success': True, 'message': f'‚è© ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§Æ‡•å‡§ú‡•Ç‡§¶', 'filename': link['filename']}
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': '*/*'
            }
            
            response = requests.get(link['url'], stream=True, timeout=60, headers=headers)
            response.raise_for_status()
            
            total_size = int(response.headers.get('content-length', 0))
            link['size'] = total_size
            
            downloaded_size = 0
            with open(filepath, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded_size += len(chunk)
                        link['downloaded'] = downloaded_size
                        
                        if total_size > 0:
                            progress = (downloaded_size / total_size) * 100
                            link['progress'] = round(progress, 1)
                        else:
                            link['progress'] = 50
                        
                        if progress_callback and downloaded_size % 81920 == 0:
                            progress_callback(link)
            
            link['status'] = 'completed'
            link['progress'] = 100
            file_size = os.path.getsize(filepath)
            
            if progress_callback:
                progress_callback(link)
                
            return {
                'success': True, 
                'message': f'‚úÖ {file_size/1024/1024:.1f} MB',
                'filename': link['filename'],
                'filepath': filepath
            }
            
        except Exception as e:
            link['status'] = 'failed'
            link['progress'] = 0
            if progress_callback:
                progress_callback(link)
            return {'success': False, 'message': f'‚ùå {str(e)}'}

    def batch_download(self, links, progress_callback=None):
        """‡§¨‡•à‡§ö ‡§Æ‡•á‡§Ç multiple ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç"""
        results = []
        
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            future_to_link = {
                executor.submit(self.download_file_with_progress, link, progress_callback): link 
                for link in links
            }
            
            for future in future_to_link:
                try:
                    result = future.result(timeout=300)
                    results.append(result)
                except Exception as e:
                    results.append({'success': False, 'message': f'‚ùå Timeout/Error: {str(e)}'})
        
        return results

class AdvancedFileDownloaderBot:
    def __init__(self, token):
        self.token = token
        self.app = Application.builder().token(token).build()
        self.downloader = AdvancedRASDownloader()
        self.user_sessions = {}
        self.setup_handlers()
    
    def setup_handlers(self):
        self.app.add_handler(CommandHandler("start", self.start_command))
        self.app.add_handler(CommandHandler("help", self.help_command))
        self.app.add_handler(CommandHandler("download_ras", self.download_ras_command))
        self.app.add_handler(CommandHandler("batch_download", self.batch_download_command))
        self.app.add_handler(CommandHandler("status", self.status_command))
        
        self.app.add_handler(CallbackQueryHandler(self.button_handler, pattern="^(download_all|download_pdf|download_video|cancel)$"))
        
        self.app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_text))
    
    def create_progress_bar(self, progress, length=20):
        """‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡•á‡§∏ ‡§¨‡§æ‡§∞ ‡§¨‡§®‡§æ‡§è‡§Ç"""
        filled = int(length * progress / 100)
        bar = '‚ñà' * filled + '‚ñë' * (length - filled)
        return f"[{bar}] {progress}%"
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        welcome_text = """
üöÄ **‡§è‡§°‡§µ‡§æ‡§Ç‡§∏‡•ç‡§° RAS ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°‡§∞ ‡§¨‡•â‡§ü**

‡§Æ‡•à‡§Ç ‡§¨‡•à‡§ö ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°, ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡•á‡§∏ ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó ‡§î‡§∞ ‡§ú‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡§∞‡§§‡§æ ‡§π‡•Ç‡§Å!

**‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏:**
/start - ‡§¨‡•â‡§ü ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç
/download_ras - ‡§∏‡§ø‡§Ç‡§ó‡§≤ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°
/batch_download - ‡§¨‡•à‡§ö ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° (‡§ú‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§´‡§æ‡§á‡§≤‡•ç‡§∏)
/status - ‡§ï‡§∞‡§Ç‡§ü ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§∏‡•ç‡§ü‡•á‡§ü‡§∏
/help - ‡§Æ‡§¶‡§¶

**‡§Ø‡§æ ‡§∏‡•Ä‡§ß‡•á ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§≠‡•á‡§ú‡•á‡§Ç** ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§≤‡§ø‡§Ç‡§ï‡•ç‡§∏ ‡§π‡•ã‡§Ç
        """
        await update.message.reply_text(welcome_text)
    
    async def batch_download_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        help_text = """
üì¶ **‡§¨‡•à‡§ö ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§´‡•Ä‡§ö‡§∞**

‡§Ø‡§π ‡§´‡•Ä‡§ö‡§∞ ‡§Ü‡§™‡§ï‡•ã:
‚úÖ ‡§è‡§ï ‡§∏‡§æ‡§• 10+ ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡§®‡•á ‡§¶‡•á‡§§‡§æ ‡§π‡•à
‚úÖ ‡§∞‡§ø‡§Ø‡§≤-‡§ü‡§æ‡§á‡§Æ ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡•á‡§∏ ‡§¨‡§æ‡§∞ ‡§¶‡§ø‡§ñ‡§æ‡§§‡§æ ‡§π‡•à  
‚úÖ ‡§™‡•à‡§∞‡§≤‡§≤ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° (‡§è‡§ï ‡§∏‡§æ‡§• 3 ‡§´‡§æ‡§á‡§≤‡•ç‡§∏)
‚úÖ ‡§ë‡§ü‡•ã‡§Æ‡•à‡§ü‡§ø‡§ï ‡§∞‡§ø‡§ü‡•ç‡§∞‡§æ‡§Ø

**‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞‡•á‡§Ç:**
1. ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ï‡•â‡§™‡•Ä ‡§ï‡§∞‡•á‡§Ç (‡§∏‡§æ‡§∞‡•á ‡§≤‡§ø‡§Ç‡§ï‡•ç‡§∏ ‡§ï‡•á ‡§∏‡§æ‡§•)
2. ‡§Æ‡•Å‡§ù‡•á ‡§≠‡•á‡§ú‡•á‡§Ç
3. ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ë‡§™‡•ç‡§∂‡§® ‡§ö‡•Å‡§®‡•á‡§Ç

‡§Ö‡§≠‡•Ä ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§≠‡•á‡§ú‡•á‡§Ç...
        """
        await update.message.reply_text(help_text)
    
    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if user_id in self.user_sessions and 'links' in self.user_sessions[user_id]:
            links = self.user_sessions[user_id]['links']
            status_text = await self.generate_status_message(links)
            await update.message.reply_text(status_text, parse_mode='HTML')
        else:
            await update.message.reply_text("‚ÑπÔ∏è ‡§ï‡•ã‡§à ‡§è‡§ï‡•ç‡§ü‡§ø‡§µ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§≠‡•á‡§ú‡§ï‡§∞ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç‡•§")
    
    async def download_ras_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        help_text = """
üìñ **RAS ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç**

‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§≠‡•á‡§ú‡•á‡§Ç ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§≤‡§ø‡§Ç‡§ï‡•ç‡§∏ ‡§π‡•ã‡§Ç‡•§ ‡§Æ‡•à‡§Ç:
- ‡§™‡§π‡§≤‡•á 5 ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§ë‡§ü‡•ã‡§Æ‡•à‡§ü‡§ø‡§ï ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ
- ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡•á‡§∏ ‡§¨‡§æ‡§∞ ‡§¶‡§ø‡§ñ‡§æ‡§ä‡§Ç‡§ó‡§æ
- ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡•á ‡§¨‡§æ‡§¶ ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§≠‡•á‡§ú ‡§¶‡•Ç‡§Ç‡§ó‡§æ

‡§Ö‡§≠‡•Ä ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§≠‡•á‡§ú‡•á‡§Ç...
        """
        await update.message.reply_text(help_text)
    
    async def handle_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_message = update.message.text
        user_id = update.effective_user.id
        
        if 'https://' not in user_message:
            await update.message.reply_text("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§≤‡§ø‡§Ç‡§ï‡•ç‡§∏ ‡§µ‡§æ‡§≤‡§æ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§≠‡•á‡§ú‡•á‡§Ç‡•§")
            return
        
        try:
            links = self.downloader.extract_links_from_text(user_message)
            
            if not links:
                await update.message.reply_text("‚ùå ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§à ‡§µ‡•à‡§≤‡§ø‡§° ‡§≤‡§ø‡§Ç‡§ï ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§")
                return
            
            self.user_sessions[user_id] = {
                'links': links,
                'start_time': time.time(),
                'status_message': None
            }
            
            total_files = len(links)
            pdf_count = sum(1 for l in links if l['type'] == 'pdf')
            video_count = sum(1 for l in links if l['type'] == 'mp4')
            
            status_msg = await update.message.reply_text(
                f"üîç <b>{total_files} ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§Æ‡§ø‡§≤‡•Ä‡§Ç</b>\n"
                f"üìÑ PDF: {pdf_count} | üé• ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã: {video_count}\n\n"
                f"‚è≥ ‡§™‡•ç‡§∞‡•ã‡§∏‡•á‡§∏‡§ø‡§Ç‡§ó...",
                parse_mode='HTML'
            )
            
            keyboard = [
                [
                    InlineKeyboardButton("üì¶ ‡§∏‡§¨ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç", callback_data="download_all"),
                    InlineKeyboardButton("üìÑ ‡§ï‡•á‡§µ‡§≤ PDF", callback_data="download_pdf")
                ],
                [
                    InlineKeyboardButton("üé• ‡§ï‡•á‡§µ‡§≤ ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã", callback_data="download_video"),
                    InlineKeyboardButton("‚ùå ‡§ï‡•à‡§Ç‡§∏‡§≤", callback_data="cancel")
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await status_msg.edit_text(
                f"üéØ <b>{total_files} ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡§Ç</b>\n"
                f"üìÑ PDF: {pdf_count} | üé• ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã: {video_count}\n\n"
                f"‡§ï‡•å‡§®‡§∏‡•Ä ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡§®‡•Ä ‡§π‡•à‡§Ç?",
                parse_mode='HTML',
                reply_markup=reply_markup
            )
            
            self.user_sessions[user_id]['status_message'] = status_msg
            
        except Exception as e:
            logger.error(f"‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {e}")
            await update.message.reply_text(f"‚ùå ‡§ï‡•Å‡§õ ‡§ó‡§≤‡§§ ‡§π‡•ã ‡§ó‡§Ø‡§æ: {str(e)}")
    
    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        data = query.data
        
        if user_id not in self.user_sessions:
            await query.edit_message_text("‚ùå Session expired. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§≠‡•á‡§ú‡•á‡§Ç‡•§")
            return
        
        links = self.user_sessions[user_id]['links']
        status_msg = self.user_sessions[user_id]['status_message']
        
        if data == "cancel":
            await query.edit_message_text("‚ùå ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡•à‡§Ç‡§∏‡§≤ ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§")
            del self.user_sessions[user_id]
            return
        
        if data == "download_pdf":
            selected_links = [link for link in links if link['type'] == 'pdf']
        elif data == "download_video":
            selected_links = [link for link in links if link['type'] == 'mp4']
        else:
            selected_links = links
        
        if not selected_links:
            await query.edit_message_text("‚ùå ‡§ö‡§Ø‡§®‡§ø‡§§ ‡§ü‡§æ‡§á‡§™ ‡§ï‡•Ä ‡§ï‡•ã‡§à ‡§´‡§æ‡§á‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡•Ä‡•§")
            return
        
        await query.edit_message_text(
            f"üöÄ <b>‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§∂‡•Å‡§∞‡•Ç...</b>\n"
            f"üì¶ {len(selected_links)} ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ selected\n"
            f"‚è≥ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...",
            parse_mode='HTML'
        )
        
        await self.start_batch_download(user_id, selected_links, status_msg)
    
    async def start_batch_download(self, user_id, links, status_msg):
        try:
            total_files = len(links)
            
            def progress_callback(link):
                asyncio.create_task(self.update_progress_message(user_id, status_msg, links))
            
            await status_msg.edit_text(
                f"üì• <b>‡§¨‡•à‡§ö ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§∂‡•Å‡§∞‡•Ç</b>\n"
                f"üì¶ ‡§ï‡•Å‡§≤ ‡§´‡§æ‡§á‡§≤‡•ç‡§∏: {total_files}\n"
                f"üöÄ ‡§è‡§ï ‡§∏‡§æ‡§• ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°: {self.downloader.max_workers}\n\n"
                f"‚è≥ ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...",
                parse_mode='HTML'
            )
            
            loop = asyncio.get_event_loop()
            with ThreadPoolExecutor() as executor:
                results = await loop.run_in_executor(
                    executor, 
                    self.downloader.batch_download, 
                    links, 
                    progress_callback
                )
            
            completed_files = sum(1 for r in results if r['success'])
            failed_files = total_files - completed_files
            
            final_message = (
                f"üéâ <b>‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§™‡•Ç‡§∞‡§æ!</b>\n\n"
                f"‚úÖ ‡§∏‡§´‡§≤: {completed_files}\n"
                f"‚ùå ‡§µ‡§ø‡§´‡§≤: {failed_files}\n"
                f"üìÅ ‡§´‡§æ‡§á‡§≤‡•ç‡§∏: ras_downloads ‡§´‡•ã‡§≤‡•ç‡§°‡§∞ ‡§Æ‡•á‡§Ç\n\n"
                f"<i>‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§ë‡§ü‡•ã‡§Æ‡•à‡§ü‡§ø‡§ï ‡§Ü‡§™‡§ï‡•ã ‡§≠‡•á‡§ú ‡§¶‡•Ä ‡§ú‡§æ‡§è‡§Ç‡§ó‡•Ä...</i>"
            )
            
            await status_msg.edit_text(final_message, parse_mode='HTML')
            
            await self.send_downloaded_files(user_id, links, status_msg)
            
        except Exception as e:
            logger.error(f"‡§¨‡•à‡§ö ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {e}")
            await status_msg.edit_text(f"‚ùå ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {str(e)}")
    
    async def update_progress_message(self, user_id, status_msg, links):
        try:
            total = len(links)
            completed = sum(1 for l in links if l['status'] == 'completed')
            downloading = sum(1 for l in links if l['status'] == 'downloading')
            failed = sum(1 for l in links if l['status'] == 'failed')
            pending = total - completed - downloading - failed
            
            current_downloads = [l for l in links if l['status'] == 'downloading']
            
            progress_text = f"üìä <b>‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡•á‡§∏</b>\n\n"
            progress_text += f"‚úÖ ‡§™‡•Ç‡§∞‡•á: {completed}/{total} | ‚è≥ ‡§ö‡§≤ ‡§∞‡§π‡•á: {downloading} | ‚ùå ‡§´‡•á‡§≤: {failed}\n\n"
            
            if current_downloads:
                for link in current_downloads[:2]:
                    progress_bar = self.create_progress_bar(link['progress'])
                    size_info = f"({link['downloaded']/1024/1024:.1f}MB/" + \
                               f"{link['size']/1024/1024:.1f}MB)" if link['size'] > 0 else ""
                    progress_text += f"üì• {link['filename'][:30]}...\n{progress_bar} {size_info}\n\n"
            else:
                progress_text += "‚è≥ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...\n\n"
            
            overall_progress = (completed / total) * 100 if total > 0 else 0
            overall_bar = self.create_progress_bar(overall_progress)
            progress_text += f"<b>‡§ï‡•Å‡§≤ ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡•á‡§∏:</b>\n{overall_bar}"
            
            await status_msg.edit_text(progress_text, parse_mode='HTML')
            
        except Exception as e:
            logger.error(f"‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡•á‡§∏ ‡§Ö‡§™‡§°‡•á‡§ü ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {e}")
    
    async def send_downloaded_files(self, user_id, links, status_msg):
        try:
            successful_links = [l for l in links if l['status'] == 'completed']
            
            await status_msg.edit_text(
                f"üì§ <b>‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§≠‡•á‡§ú ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å...</b>\n"
                f"‚úÖ {len(successful_links)} ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡§Ç\n"
                f"‚è≥ ‡§ï‡•É‡§™‡§Ø‡§æ wait ‡§ï‡§∞‡•á‡§Ç...",
                parse_mode='HTML'
            )
            
            for i, link in enumerate(successful_links):
                filepath = os.path.join(self.downloader.download_dir, link['filename'])
                
                if os.path.exists(filepath):
                    try:
                        with open(filepath, 'rb') as file:
                            if link['type'] == 'pdf':
                                await self.app.bot.send_document(
                                    chat_id=user_id,
                                    document=file,
                                    filename=link['filename'],
                                    caption=f"üìÑ {link['subject']}\n{link['description']}"
                                )
                            elif link['type'] == 'mp4':
                                await self.app.bot.send_video(
                                    chat_id=user_id,
                                    video=file,
                                    caption=f"üé• {link['subject']}\n{link['description']}"
                                )
                        
                        progress = ((i + 1) / len(successful_links)) * 100
                        await status_msg.edit_text(
                            f"üì§ <b>‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§≠‡•á‡§ú ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å...</b>\n"
                            f"‚úÖ {i + 1}/{len(successful_links)} ‡§≠‡•á‡§ú ‡§¶‡•Ä ‡§ó‡§à\n"
                            f"{self.create_progress_bar(progress)}",
                            parse_mode='HTML'
                        )
                        
                    except Exception as e:
                        logger.error(f"‡§´‡§æ‡§á‡§≤ ‡§≠‡•á‡§ú‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø {link['filename']}: {e}")
                
                await asyncio.sleep(1)
            
            await status_msg.edit_text(
                f"üéâ <b>‡§∏‡§¨ ‡§ï‡•Å‡§õ ‡§™‡•Ç‡§∞‡§æ!</b>\n\n"
                f"‚úÖ {len(successful_links)} ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§≠‡•á‡§ú ‡§¶‡•Ä ‡§ó‡§à‡§Ç\n"
                f"üìÅ ‡§≤‡•ã‡§ï‡§≤ ‡§ï‡•â‡§™‡•Ä: ras_downloads ‡§´‡•ã‡§≤‡•ç‡§°‡§∞ ‡§Æ‡•á‡§Ç\n\n"
                f"<i>‡§®‡§è ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§≠‡•á‡§ú‡•á‡§Ç!</i>",
                parse_mode='HTML'
            )
            
            if user_id in self.user_sessions:
                del self.user_sessions[user_id]
                
        except Exception as e:
            logger.error(f"‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§≠‡•á‡§ú‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {e}")
            await status_msg.edit_text(f"‚ùå ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§≠‡•á‡§ú‡§®‡•á ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {str(e)}")
    
    async def generate_status_message(self, links):
        total = len(links)
        completed = sum(1 for l in links if l['status'] == 'completed')
        downloading = sum(1 for l in links if l['status'] == 'downloading')
        failed = sum(1 for l in links if l['status'] == 'failed')
        
        status_text = f"<b>üìä ‡§ï‡§∞‡§Ç‡§ü ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§∏‡•ç‡§ü‡•á‡§ü‡§∏</b>\n\n"
        status_text += f"üì¶ ‡§ï‡•Å‡§≤ ‡§´‡§æ‡§á‡§≤‡•ç‡§∏: {total}\n"
        status_text += f"‚úÖ ‡§™‡•Ç‡§∞‡•á: {completed}\n"
        status_text += f"üì• ‡§ö‡§≤ ‡§∞‡§π‡•á: {downloading}\n"
        status_text += f"‚ùå ‡§´‡•á‡§≤: {failed}\n\n"
        
        if downloading > 0:
            current = [l for l in links if l['status'] == 'downloading']
            status_text += "<b>‡§ö‡§≤ ‡§∞‡§π‡•á ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°:</b>\n"
            for link in current[:3]:
                progress_bar = self.create_progress_bar(link['progress'])
                status_text += f"‚Ä¢ {link['filename'][:25]}...\n{progress_bar}\n"
        
        return status_text
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        help_text = """
üÜò <b>‡§è‡§°‡§µ‡§æ‡§Ç‡§∏‡•ç‡§° RAS ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°‡§∞ - ‡§π‡•á‡§≤‡•ç‡§™</b>

<u>‡§´‡•Ä‡§ö‡§∞‡•ç‡§∏:</u>
‚Ä¢ üì¶ ‡§¨‡•à‡§ö ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° - ‡§è‡§ï ‡§∏‡§æ‡§• 10+ ‡§´‡§æ‡§á‡§≤‡•ç‡§∏
‚Ä¢ üìä ‡§∞‡§ø‡§Ø‡§≤-‡§ü‡§æ‡§á‡§Æ ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡•á‡§∏ - ‡§≤‡§æ‡§á‡§µ ‡§Ö‡§™‡§°‡•á‡§ü
‚Ä¢ üöÄ ‡§™‡•à‡§∞‡§≤‡§≤ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° - ‡§è‡§ï ‡§∏‡§æ‡§• 3 ‡§´‡§æ‡§á‡§≤‡•ç‡§∏
‚Ä¢ üîÑ ‡§ë‡§ü‡•ã ‡§∞‡§ø‡§ü‡•ç‡§∞‡§æ‡§Ø - ‡§´‡•á‡§≤ ‡§π‡•ã‡§®‡•á ‡§™‡§∞ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§ï‡•ã‡§∂‡§ø‡§∂
‚Ä¢ üìÅ ‡§ë‡§ü‡•ã ‡§∏‡•á‡§®‡•ç‡§° - ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡•á ‡§¨‡§æ‡§¶ ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§≠‡•á‡§ú‡•á‡§Ç

<u>‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏:</u>
/start - ‡§¨‡•â‡§ü ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç
/download_ras - ‡§∏‡§ø‡§Ç‡§ó‡§≤ ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°
/batch_download - ‡§¨‡•à‡§ö ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§°
/status - ‡§ï‡§∞‡§Ç‡§ü ‡§∏‡•ç‡§ü‡•á‡§ü‡§∏ ‡§¶‡•á‡§ñ‡•á‡§Ç
/help - ‡§Ø‡§π ‡§Æ‡•à‡§∏‡•á‡§ú

<u>‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞‡•á‡§Ç:</u>
1. ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ï‡•â‡§™‡•Ä ‡§ï‡§∞‡•á‡§Ç (‡§∏‡§æ‡§∞‡•á ‡§≤‡§ø‡§Ç‡§ï‡•ç‡§∏ ‡§ï‡•á ‡§∏‡§æ‡§•)
2. ‡§¨‡•â‡§ü ‡§ï‡•ã ‡§≠‡•á‡§ú‡•á‡§Ç  
3. ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ë‡§™‡•ç‡§∂‡§® ‡§ö‡•Å‡§®‡•á‡§Ç
4. ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡•á‡§∏ ‡§¶‡•á‡§ñ‡•á‡§Ç ‡§î‡§∞ ‡§´‡§æ‡§á‡§≤‡•ç‡§∏ ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç
        """
        await update.message.reply_text(help_text, parse_mode='HTML')

def check_environment():
    bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
    if not bot_token:
        print("‚ùå TELEGRAM_BOT_TOKEN environment variable not set!")
        return False
    print("‚úÖ Environment check passed!")
    return True

def main():
    print("üöÄ Starting Advanced RAS File Downloader Bot...")
    
    if not check_environment():
        return
    
    BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
    
    try:
        print("ü§ñ Initializing advanced bot...")
        bot = AdvancedFileDownloaderBot(BOT_TOKEN)
        print("‚úÖ Bot initialized successfully!")
        print("üì¶ Features: Batch Download, Progress Bar, Multiple Files Support")
        
        bot.app.run_polling()
        
    except Exception as e:
        print(f"‚ùå Failed to start bot: {e}")

if __name__ == '__main__':
    main()